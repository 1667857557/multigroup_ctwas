---
title: "Simple cTWAS tutorial without LD"
author: "Kaixuan Luo, Sheng Qian"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simple cTWAS tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE,
                      fig.align = "center",
                      fig.cap = "&nbsp;",
                      dpi = 120)
```

This document demonstrates how to run a simple analysis using cTWAS with GWAS summary statistics. Running cTWAS involves several steps: preparing input data, computing z-scores of molecular traits, assembling the input data for the regions, estimating parameters, screening regions with strong signals, and fine-mapping the variants and molecular traits. 

In this tutorial, we will show how to perform cTWAS main analysis with summary statistics without using LD matrices. 

Load the `ctwas` package and some other packages needed for summarizing and visualizing cTWAS result
```{r load_packages, message=FALSE}
library(ctwas)
library(tidyverse)
library(locuszoomr)
```

We also need gene annotations from the Ensembl database. We use `EnsDb.Hsapiens.v86` for the example data, please choose the Ensembl database for your specific data. 
```{r load_ens_db}
library(EnsDb.Hsapiens.v86)
```

We require first running the data preprocessing and harmonization steps before running cTWAS analysis. Please read the tutorial [Preparing cTWAS input data]() to prepare cTWAS input data.

In this tutorial, we use sample data for chromosome 16 provided in the package. 

```{r load_ctwas_res, eval=FALSE}
# load sample data
datadir <- "/project2/xinhe/shared_data/multigroup_ctwas/tutorial/LDL_multitissue_tutorial/sample_data/LDL_example"

# Load z_snp
z_snp <- readRDS(system.file("extdata/ldetect", "LDL_example.z_snp.RDS", package = "ctwas"))
```


We also need the GWAS sample size for summarizing the cTWAS result
```{r}
# GWAS sample size
gwas_n <- 343621
```

### Region info

We require a data frame `region_info` containing the information of the regions, with the following columns: "chrom", "start", "stop", "region_id". "chrom", "start", "stop" are the genomic coordinates of the regions, "region_id" contains the IDs of the region, and we use "chr:start-stop" format in region IDs by default.

Here we use the b38 European region file, which is included in the package.

```{r region_info, eval=FALSE}
region_file <- system.file("extdata/ldetect", paste0("EUR.b38.bed"), package = "ctwas")
region_info <- read.table(region_file, header = TRUE)
colnames(region_info)[1:3] <- c("chrom", "start", "stop")
region_info$chrom <- as.numeric(gsub("chr", "", region_info$chrom))
region_info$region_id <- paste0(region_info$chr, ":", region_info$start, "-", region_info$stop)
```

## SNP info

We will need to have a list of SNPs as a “reference”, with the information of these SNPs. We provide a function, `map_snp_info_regions()` to map variants to regions from the LD reference, which takes input of `region_info` and a data frame of variant information from the entire genome, and returns a data frame `snp_info` of variant information in each region.

```{r, eval=FALSE}
ld_ref_dir <- "/project2/xinhe/shared_data/multigroup_ctwas/LD_reference/"
filestem <- paste0("ukb_", genome_version, "_0.1")
ref_snp_info <- data.table::fread(file.path(ld_ref_dir, paste0(filestem, "_var_info.Rvar.gz")), sep = "\t")
snp_info <- map_snp_info_regions(region_info, ref_snp_info, ncore = ncore)
```

### Harmonizing GWAS z-scores and the reference data

The `preprocess_z_snp()` function harmonizes GWAS z-scores and the reference data in `snp_info`. We drop multiallelic variants and drop strand ambiguous variants, by default.

```{r preprocess_z_snp, eval=FALSE}
# preprocessing z_snp
z_snp <- preprocess_z_snp(z_snp, 
                          snp_info, 
                          drop_multiallelic = TRUE, 
                          drop_strand_ambig = TRUE)
```

### Harmonizing prediction models and the reference data

The `preprocess_weight()` function harmonizes the PredictDB/FUSION prediction models and LD reference. 

In this example, we use liver and subcutaneous adipose gene expression models. We specify the `type` and `context` arguments for each weight file. 
We preprocess each of the weight files, and then simply concatenate them to get a list of all processed weights.

```{r preprocess_weights, eval=FALSE}
weight_liver_file <- system.file("extdata/ldetect", "mashr_Liver.db", package = "ctwas"))

weights_liver <- preprocess_weights(weight_liver_file,
                                    region_info,
                                    z_snp$id,
                                    snp_info,
                                    type = "expression",
                                    context = "liver",
                                    weight_format = "PredictDB",
                                    ncore = 6,
                                    drop_strand_ambig = TRUE,
                                    scale_by_ld_variance = TRUE,
                                    load_predictdb_LD = TRUE,
                                    filter_protein_coding_genes = TRUE)

weight_adipose_file <- system.file("extdata/ldetect", "mashr_Adipose_Subcutaneous.db", package = "ctwas"))

weights_adipose <- preprocess_weights(weight_adipose_file,
                                      region_info,
                                      z_snp$id,
                                      snp_info,
                                      type = "expression",
                                      context = "adipose",
                                      weight_format = "PredictDB",
                                      ncore = 6,
                                      drop_strand_ambig = TRUE,
                                      scale_by_ld_variance = TRUE,
                                      load_predictdb_LD = TRUE,
                                      filter_protein_coding_genes = TRUE)

weights <- c(weights_liver, weights_adipose)
```

## Running cTWAS analysis without LD

We use the function `ctwas_sumstats_noLD()` to run cTWAS analysis without LD. It takes preprocessed GWAS z-scores (`z_snp`), `weights`, `region_info`, `snp_info` as input, and will perform the main steps: computing z_scores of molecular traits, assembling input `region_data`, estimating parameters, screening regions, and finemapping. 

If `z_gene` is already computed when preparing cTWAS input data, we could specify the `z_gene` argument in the function, then it will skip computing z-scores of molecular traits.

```{r ctwas_sumstats_noLD, eval=FALSE}
ctwas_res <- ctwas_sumstats_noLD(z_snp,
                                 weights,
                                 region_info,
                                 snp_info,
                                 thin = 0.1,
                                 niter_prefit = 3,
                                 niter = 30,
                                 group_prior_var_structure = "shared_type",
                                 maxSNP = 20000,
                                 min_nonSNP_PIP = 0.5,
                                 ncore = 6)

param <- ctwas_res$param
finemap_res <- ctwas_res$finemap_res
boundary_genes <- ctwas_res$boundary_genes
z_gene <- ctwas_res$z_gene
region_data <- ctwas_res$region_data
screened_region_data <- ctwas_res$screened_region_data
```

Major argument settings:

-   `z_snp` is a data frame with preprocessed GWAS z-scores.
-   `weights` is a list of preprocessed weights from PredictDB or FUSION prediction models.
-   `region_info` is a data frame with genome coordinates, LD matrix and SNP info of all the regions
-   `snp_info` is a list of reference SNP info in each of the regions.
-   The `thin` argument randomly selects a subset of variants (10% when thin = 0.1) to use during the parameter estimation and screening regions, reducing computation.
-   The `niter_prefit` argument and `niter` argument sets the number of EM iterations for estimating parameters. We set `niter_prefit = 3`, and `niter = 30` by default.
-   There are several options for how to handle the prior effect size parameters by specifying the `group_prior_var_stucture`. "shared_type" (default option) allows all groups in one molecular QTL type to share the same variance parameter. "shared_context" allows all groups in one context (tissue, cell type, condition) to share the same variance parameter. "shared_nonSNP" allows all non-SNP groups to share the same variance parameter. "shared_all" allows all groups to share the same variance parameter. "independent" allows all groups to have their own separate variance parameters.
-   The `maxSNP` sets a maximum on the number of variants that can be in a single region to prevent memory issues during fine-mapping.
-   `min_nonSNP_PIP` is a threshold for selecting regions with strong non-SNP signals for finemapping. We set `min_nonSNP_PIP = 0.5` by default, so regions with total non-SNP signals greater than 0.5 will be selected for finemapping.
-   The `ncore` argument specifies the number of cores to use when parallelizing over regions.

The function returns a list including: 
estimated parameters, fine-mapping results, boundary genes, z-scores of molecular traits, assembled region data for all the regions and region data with full SNPs for selected regions.

## Summarizing cTWAS result

### Assessing parameters and computing PVE

We could use the function `summarize_param()` to assess the convergence of the estimated parameters and to compute the proportion of variance explained (PVE) by variants and genes. 
```{r summarize_param}
ctwas_parameters <- summarize_param(param, gwas_n)
```

```{r}
# Estimated prior inclusion probability
ctwas_parameters$group_prior

# Estimated prior effect size:
ctwas_parameters$group_prior_var

# Estimated enrichment of molecular traits over variants:
ctwas_parameters$enrichment

# PVE explained by molecular traits and variants:
ctwas_parameters$group_pve

# Total heritability (sum of PVE)
ctwas_parameters$total_pve

# Attributable heritability
ctwas_parameters$attributable_pve
```

Plot convergence
```{r convergence_plot, fig.width = 7, fig.height=5}
ctwas_parameters$convergence_plot
```

## Interpreting cTWAS results

To interpret the results, we add gene names (from Ensembl database) to the finemapping result, and use mid-points to represent gene positions.
```{r add_gene_names}
# load gene info database
ens_db <- EnsDb.Hsapiens.v86

# add gene names and use gene mid-points to represent gene positions
finemap_res <- anno_finemap_res(finemap_res, snp_info, ens_db, use_gene_pos = "mid")
```


We list all molecular traits with PIP > 0.8, which is the threshold we used in the paper.
```{r interpret_res, eval=FALSE}
# select PIP > 0.8
sig_finemap_res <- finemap_res[finemap_res$type!="SNP" & finemap_res$susie_pip > 0.8,]

head(sig_finemap_res[order(-sig_finemap_res$susie_pip),])
```

When we have multiple contexts (tissues), 
it is useful to evaluate the combined PIP for each molecular trait over different contexts:

```{r combine_pips, eval=FALSE}
# combine PIPs across contexts (tissues)
combined_gene_pips <- sum_pip_across_contexts(finemap_res)

# select combined PIP > 0.8
sig_gene_pips_df <- combined_gene_pips[combined_gene_pips$combined_pip > 0.8, ]

# list genes with combined PIP > 0.8 or top 20 genes with highest combined PIPs
head(combined_gene_pips, max(nrow(sig_gene_pips_df), 20))
```


## Visualizing cTWAS results

We could make locus plots for regions of interest,
and zoom in the region by specifying the `locus_range`.
```{r locus_plot, fig.width=10, fig.height=8}
unique(finemap_res$region_id)
make_locusplot(finemap_res,
               region_id = "16:71020125-72901251",
               weights = weights,
               ens_db = ens_db,
               use_LD = FALSE,
               pip_thresh = 0.8,
               locus_range = c(71.6e6,72.4e6))
```

