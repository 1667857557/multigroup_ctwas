---
title: "Pipepline of using multigroup cTWAS with summary statistics"
author: "Kaixuan Luo, Sheng Qian"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pipepline of using multigroup cTWAS with summary statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=FALSE,
                      message = FALSE,
                      warning = FALSE,
                      fig.width = 6,
                      fig.height = 4,
                      fig.align = "center",
                      fig.cap = "&nbsp;",
                      dpi = 120)
```

This document shows the updated pipeline for running cTWAS with summary statistics using the `multi-group` version of the R package, 
which extends our earlier cTWAS method (single group version) to integrate multiple groups of prediction models. 

## Installation

Install the `multigroup` branch of `cTWAS` package

```{r install_package, eval=FALSE}
remotes::install_github("xinhe-lab/ctwas", ref = "multigroup")
```

Load the package

```{r load_package, eval=FALSE}
library(ctwas)
```

## Preparing input data

In this version of `cTWAS` package, we require first running the data preprocessing and harmonization steps 
before running parameter estimation and finemapping steps of cTWAS analysis. 

The inputs for the summary statistics version of cTWAS include GWAS summary statistics, 
prediction models for genes in PredictDB format, and LD reference. 

### GWAS z-scores

We read the GWAS summary statistics as a data frame `z_snp`, with columns "id", "A1", "A2", "z", and each row is a variant. 
`A1` is the alternate allele, and `A2` is the reference allele. 

We also need to specify the GWAS sample size.

### Prediction models

The `multigroup` version of cTWAS only accepts multiple sets of prediction models in PredictDB format. 
We provide functions to convert weights from FUSION format to PredictDB format.

To specify weights in PredictDB format, provide the path to the `.db` file. Multiple prediction models can be specified by providing multiple paths as a vector.

### LD reference and region info

LD reference information can be provided as genetic correlation matrices (termed "R matrices") 
for regions that are approximately LD-independent. 

It is critical that the genome build (e.g. hg38) of the LD reference matches the genome build used to train the prediction models. 
The genome build of the GWAS summary statistics does not matter because variant positions are determined by the LD reference.

cTWAS includes pre-defined regions based on European (EUR), Asian (ASN), or African (AFR) populations, 
using either genome build b38 or b37.
These regions were previously generated using [LDetect](https://github.com/endrebak/ldetect). 

In this version of the package, we also require a data frame `region_info` containing the following columns: 
"chrom", "start", "end", "region_name", "LD_matrix", "SNP_info".

"chrom", "start", "end" are the genomic coordinates of the regions, 
"LD_matrix" stores the paths to the precomputed LD (R) matrices (`.RDS` files in our UK Biobank reference),
"SNP_info" stores the paths to the variant information corresponding to the LD matrices (`.Rvar` files in our UK Biobank reference). 

### Data harmonization

These inputs should be harmonized prior to cTWAS analysis (i.e. the reference and alternative alleles for each variant should match across all three data sources). 

#### Harmonizing GWAS z-scores and LD reference and detect LD mismatches

The `preprocess_z_ld()` function first harmonizes GWAS z-scores and LD reference based on the included allele information, 
then performs LD mismatch diagnosis using the `kriging_rss()` function from SuSiE RSS, 
and flips signs for variants detected with allele flipping issues. 
Note, the LD mismatch diagnosis procedure can be time consuming.

#### Harmonizing prediction models and LD reference

The `preprocess_wgt_ld()` function harmonizes the PredictDB prediction models and LD reference. 
This only needs to be done once per combination of prediction models and LD reference. 

## Imputing gene z-scores

After we have done data harmonization, we compute gene z-scores genome-wide using `compute_gene_z()`. 

This function computes gene z-scores using GWAS summary statistics (`z_snp`), the PredictDB weights, 
and the LD matrix information included in `region_info`.
It returns computed gene z-scores (`z_gene`), a data frame about the imputed genes (`gene_info`), 
and the weights of imputed genes (`wgtlist`).
```{r, eval=FALSE}
compute_gene_z(z_snp, weights, region_info, ncore, ...)
```

## Estimating parameters

We need to specify the GWAS summary statistics (`z_snp`), results from computing gene z-scores (including `z_gene`, `gene_info`), and `region_info`. 
We also specify `thin`, the proportion of SNPs to be used for parameter estimation and screening regions.

In the `multigroup` branch, to specify that our gene z-scores come from multiple groups, 
we simply add a `type` column specifying the types of tissue groups, 
and we and also add a `QTLtype` column for the types of molecular traits.

There are several options for how to handle the effect size prior by specifying the `group_prior_var_stucture`:

  - "independent" is the default and allows all groups to have their own separate variance parameters. 
  - "shared" allows all groups to share the same variance parameter.
  - "shared+snps" allows all groups to share the same variance parameter, and this variance parameter is also shared with SNPs.
  - "shared_type" allows all groups in one molecular QTL type to share the same variance parameter.

This step will run EM algorithm to estimate parameters. 

It will first get downsampled SNPs (with `thin`) for each region, 
then iteratively run `susie_rss` with L = 1 (first on all regions to get rough estimates and then on filtered regions to get accurate estimates),
and then estimate parameters (`group_prior` and `group_prior_var`).

```{r, eval=FALSE}
est_param(z_snp, z_gene, region_info, gene_info, thin, group_prior_var_structure, ...)
```

We could use `ctwas_summarize_parameters()` to assess the convergence of the estimated parameters and 
to compute the proportion of variance explained (PVE) by variants and genes. 

## Screening regions

This step will run a screening process to fine-map all regions with downsampled SNPs,
(we set `L = 1` as default in this version to shorten running time, instead of `L = 5` as in the earlier version), 
and select regions with strong gene signals (`min_gene_PIP = 0.5` by default). 

```{r, eval=FALSE}
screen_regions(z_snp, z_gene, region_info, gene_info, wgtlist, regionlist, 
               group_prior, group_prior_var, min_gene_PIP = 0.5, ...)
```

## Fine-mapping

We now perform the fine-mapping step with the estimated parameters for each of screened regions.

The `finemap_region` function performs finemapping for a single region, as specified by `region_tag`. 
We could run this function through each of selected regions or any region of interest.

It first computes correlation matrices (SNP-SNP, SNP-gene, and gene-gene correlation matrices) using all SNPs in the region, 
and then runs fine-mapping with L = 5 with estimated parameters (`group_prior` and `group_prior_var`),
and returns a data frame with annotated finemapping results for the region.

If `save_LD_R = TRUE`, it will save the computed correlation matrices to `outputdir` for future access.

```{r, eval=FALSE}
finemap_region(z_snp, z_gene, region_info, gene_info, wgtlist, regionlist, region_tag, 
               L = 5, group_prior, group_prior_var, save_LD_R, outputdir, outname, ...)
```

## Postprocessing

### Rerun finemapping with L = 1 for regions with problematic SNPs 

We will rerun the fine-mapping with L = 1 for the regions containing high PIP (>0.5) SNPs 
detected with LD-mismatch issue in the preprocessing step, 
or high PIP genes with problematic SNPs in their weights. 

```{r, eval=FALSE}
rerun_finemap_regions_L1(z_snp, z_gene, problematic_snps, wgtlist, pip_thresh = 0.5, ...)
```

### Region merging


## Visualzing cTWAS results

We could use `ctwas_locus_plot()` function to make locus plot for a region of interest.

