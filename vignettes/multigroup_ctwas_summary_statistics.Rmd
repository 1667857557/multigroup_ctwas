---
title: "Using cTWAS multigroup version with summary statistics"
author: "Kaixuan Luo, Sheng Qian, Wesley Crouse, Xin He"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using cTWAS multigroup version with summary statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=FALSE,
                      message = FALSE,
                      warning = FALSE,
                      fig.width = 6,
                      fig.height = 4,
                      fig.align = "center",
                      fig.cap = "&nbsp;",
                      dpi = 120)
```

## Overview

This document is a tutorial for running cTWAS with summary statistics using the `multi-group` version of the R package, which extends our earlier cTWAS method (single group version) to integrate multiple groups of prediction models. This can be used to jointly analyze gene expression from multiple tissues, and/or to jointly analyze prediction models from different types of -omics data.

In this tutorial, we will show one example to jointly model gene expression from multiple tissues, but the same framework could also be used to jointly modeling multiple molecular QTL data types (with slight change of the parameter settings). 

This document assumes that you have already read the main tutorial for cTWAS (single group version), available [here](https://xinhe-lab.github.io/ctwas/articles/ctwas_summary_statistics.html).


## Getting started

Install the `multigroup` branch of `cTWAS` package

```{r install_package, eval=FALSE}
remotes::install_github("xinhe-lab/ctwas", ref = "multigroup")
```

Load the package and set the working directory where you want to perform the analysis.

```{r load_package}
library(ctwas)
```

```{r}
#set the working directory interactively
setwd("/project2/xinhe/shared_data/multigroup_ctwas_tutorial")

#set the working directory when compiling this document with Knitr
knitr::opts_knit$set(root.dir = "/project2/xinhe/shared_data/multigroup_ctwas_tutorial")
```

## Preparing input data

The inputs for the summary statistics version of cTWAS include GWAS summary statistics for variants, prediction models for genes in PredictDB format, and LD reference. 

We used the directories and files on the University of Chicago RCC cluster as examples. If you are at UChicago, you can load those data from RCC as below.

### GWAS z-scores

For this analysis, we will use summary statistics from a GWAS of LDL cholesterol in the UK Biobank. We will download the VCF from the IEU Open GWAS Project. 

```{r, eval=FALSE}
# set the working directory, download the summary statistics, and unzip the file.
dir.create("gwas_summary_stats")

system("wget https://gwas.mrcieu.ac.uk/files/ukb-d-30780_irnt/ukb-d-30780_irnt.vcf.gz -P gwas_summary_stats")
R.utils::gunzip("gwas_summary_stats/ukb-d-30780_irnt.vcf.gz")
```

Next, we will read the summary statistics. Then, we will compute the z-scores and format the input data. We will also collect the sample size, which will be useful later. We will save this output for convenience.

```{r, eval=FALSE}
# read the data using the VariantAnnotation package
z_snp <- VariantAnnotation::readVcf("gwas_summary_stats/ukb-d-30780_irnt.vcf")
z_snp <- as.data.frame(gwasvcf::vcf_to_tibble(z_snp))

# compute the z-scores
z_snp$Z <- z_snp$ES/z_snp$SE

# collect sample size (most frequent sample size for all variants)
gwas_n <- as.numeric(names(sort(table(z_snp$SS),decreasing=TRUE)[1]))

# subset the columns and format the column names
z_snp <- z_snp[,c("rsid", "ALT", "REF", "Z")]
colnames(z_snp) <- c("id", "A1", "A2", "z")

# drop multiallelic variants (id not unique)
z_snp <- z_snp[!(z_snp$id %in% z_snp$id[duplicated(z_snp$id)]),]

# save the formatted z-scores and GWAS sample size
saveRDS(z_snp, file="gwas_summary_stats/ukb-d-30780_irnt.RDS")
saveRDS(gwas_n, file="gwas_summary_stats/gwas_n.RDS")
```

After the previous step, we can load the data and look at the format. `z_snp` is a data frame, and each row is a variant. `A1` is the alternate allele, and `A2` is the reference allele. The sample size for this GWAS is `N=343,621`.

```{r load_z_snp}
z_snp <- readRDS("gwas_summary_stats/ukb-d-30780_irnt.RDS")
gwas_n <- readRDS("gwas_summary_stats/gwas_n.RDS")

head(z_snp)

# sample size
gwas_n 
```

### Prediction models

The `multigroup` version of cTWAS only accepts multiple sets of prediction models in PredictDB format. A single set of prediction models can still be specified in FUSION format, as in the `main` branch. See the [section](https://xinhe-lab.github.io/ctwas/articles/prediction_models.html) on converting between FUSION and PredictDB weights for guidance on using multiple sets of FUSION weights. 

To specify weights in PredictDB format, provide the path to the `.db` file. Multiple prediction models can be specified by providing multiple paths as a vector.

For this analysis, we will use liver and subcutaneous adipose gene expression models trained on GTEx v8 in the PredictDB format. We will download both the prediction models (`.db`) and the covariances between variants in the prediction models (`.txt.gz`). The covariances can optionally be used during harmonization to recover strand ambiguous variants.

```{r, eval=FALSE}
# download the files
system("wget https://zenodo.org/record/3518299/files/mashr_eqtl.tar")

# extract to ./weights folder 
system("mkdir weights")
system("tar -xvf mashr_eqtl.tar -C weights")
system("rm mashr_eqtl.tar")
```

We also remove lncRNAs from the prediction models:

```{r, eval=FALSE}
library(RSQLite)

##### processing liver weights

# specify the weight to remove lncRNA from
weight <- "weights/eqtl/mashr/mashr_Liver.db"

# read the PredictDB weights
sqlite <- dbDriver("SQLite")
db = dbConnect(sqlite, weight)
query <- function(...) dbGetQuery(db, ...)
weights_table <- query("select * from weights")
extra_table <- query("select * from extra")
dbDisconnect(db)

# subset to protein coding genes only
extra_table <-  extra_table[extra_table$gene_type=="protein_coding",,drop=F]
weights_table <- weights_table[weights_table$gene %in% extra_table$gene,]

# read and subset the covariances
weight_info = read.table(gzfile(paste0(tools::file_path_sans_ext(weight), ".txt.gz")), header = T)
weight_info <- weight_info[weight_info$GENE %in% extra_table$gene,]

# write the .db file and the covariances
dir.create("weights_nolnc", showWarnings=F)

if (!file.exists("weights_nolnc/mashr_Liver_nolnc.db")){
  db <- dbConnect(sqlite, "weights_nolnc/mashr_Liver_nolnc.db")
  dbWriteTable(db, "extra", extra_table)
  dbWriteTable(db, "weights", weights_table)
  dbDisconnect(db)

  weight_info_gz <- gzfile("weights_nolnc/mashr_Liver_nolnc.txt.gz", "w")
  write.table(weight_info, weight_info_gz, sep=" ", quote=F, row.names=F, col.names=T)
  close(weight_info_gz)
}

##### processing adipose weights

# specify the weight to remove lncRNA from
weight <- "weights/eqtl/mashr/mashr_Adipose_Subcutaneous.db"

# read the PredictDB weights
sqlite <- dbDriver("SQLite")
db = dbConnect(sqlite, weight)
query <- function(...) dbGetQuery(db, ...)
weights_table <- query("select * from weights")
extra_table <- query("select * from extra")
dbDisconnect(db)

# subset to protein coding genes only
extra_table <-  extra_table[extra_table$gene_type=="protein_coding",,drop=F]
weights_table <- weights_table[weights_table$gene %in% extra_table$gene,]

# read and subset the covariances
weight_info = read.table(gzfile(paste0(tools::file_path_sans_ext(weight), ".txt.gz")), header = T)
weight_info <- weight_info[weight_info$GENE %in% extra_table$gene,]

# write the .db file and the covariances
dir.create("weights_nolnc", showWarnings=F)

if (!file.exists("weights_nolnc/mashr_Adipose_Subcutaneous_nolnc.db")){
  db <- dbConnect(sqlite, "weights_nolnc/mashr_Adipose_Subcutaneous_nolnc.db")
  dbWriteTable(db, "extra", extra_table)
  dbWriteTable(db, "weights", weights_table)
  dbDisconnect(db)

  weight_info_gz <- gzfile("weights_nolnc/mashr_Adipose_Subcutaneous_nolnc.txt.gz", "w")
  write.table(weight_info, weight_info_gz, sep=" ", quote=F, row.names=F, col.names=T)
  close(weight_info_gz)
}

rm(extra_table, weight_info, weights_table, weight_info_gz, sqlite, db)
```

We specify these processed prediction models as a vector of paths:

```{r}
weight <- c("weights_nolnc/mashr_Liver_nolnc.db", "weights_nolnc/mashr_Adipose_Subcutaneous_nolnc.db")
```

### LD reference and regions

LD reference information can be provided to cTWAS as either individual-level genotype data (in PLINK format), or as genetic correlation matrices (termed "R matrices") for regions that are approximately LD-independent. These regions must also be specified, regardless of how the LD reference information is provided.

We will use the regions and LD matrices specified in the user guide for the `main` branch of cTWAS.

```{r}
ld_R_dir <- "/project2/mstephens/wcrouse/UKB_LDR_0.1/"
```

## Data harmonization and preprocessing 

These inputs should be harmonized prior to analysis (i.e. the reference and alternative alleles for each variant should match across all three data sources). 

### Harmonizing GWAS z-scores and LD reference and LD mismatch diagnoisis

We perform the harmonization and LD mismatch diagnoisis of z-scores here:

```{r}
outputdir <- "results/multigroup/"
outname <- "example_multigroup"

dir.create(outputdir, showWarnings=F, recursive=T)

# harmonize variant z scores
if (file.exists(paste0(outputdir, outname, "_z_snp.Rd"))){
  load(file = paste0(outputdir, outname, "_z_snp.Rd"))
} else {
  res <- ctwas:::preharmonize_z_ld(z_snp=z_snp, 
                           ld_R_dir=ld_R_dir, 
                           outputdir=outputdir,
                           outname=outname,
                           harmonize_z=T, 
                           strand_ambig_action_z="none")
  z_snp <- res$z_snp
  save(z_snp, file = paste0(outputdir, outname, "_z_snp.Rd"))
  rm(res)
}

```

### Harmonizing prediction models and LD reference

When using multiple sets of prediction models, or using the same combination of prediction models and LD reference multiple times, it is beneficial to harmonize the prediction models and LD reference before the analysis. Harmonization only needs to be done once per combination of prediction models and LD reference. 

The output is a harmonized `.db` file in the output directory; we do not return the harmonized covariances between variants in the prediction models (`.txt.gz`).

```{r, eval=F}
preharmonize_wgt_ld(weight="weights_nolnc/mashr_Liver_nolnc.db",
                    ld_R_dir = ld_R_dir,
                    outputdir = "weights_nolnc/",
                    outname = "mashr_Liver_nolnc_harmonized",
                    strand_ambig_action_wgt = "recover")

preharmonize_wgt_ld(weight="weights_nolnc/mashr_Adipose_Subcutaneous_nolnc.db",
                    ld_R_dir = ld_R_dir,
                    outputdir = "weights_nolnc/",
                    outname = "mashr_Adipose_Subcutaneous_nolnc_harmonized",
                    strand_ambig_action_wgt = "recover")
```

## Running cTWAS genome-wide with multiple weights

We now provide a workflow for the genome-wide analysis using cTWAS and multiple groups of weights. This can be computationally intensive. We performed these analyses with 10 cores and 56GB of RAM, although the exact resource requirements will vary with the numbers of genes and variants provided.

### Imputing gene z-scores

After we have done data harmonization and preprocessing, we specify the harmonized weights as a vector and impute the gene z-scores. 

To impute gene z-scores genome-wide, we specify the GWAS summary statistics, both the PredictDB liver and adipose weights, and the LD reference matrices. 

If specifying only a single `.db` file (or a single set of FUSION weights), the output of this function using the `multigroup` branch is identical to the output using the `main` branch. If specifying more than one `.db` file, the gene names will have the name of the corresponding `.db` file appended after the gene name, e.g. "gene1|mashr_Liver_nolnc", but otherwise the output is the same.

Here, we impute gene z-scores for individual chromosomes using multiple cores, and then combining the results:

```{r}
weight <- c("weights_nolnc/mashr_Liver_nolnc_harmonized.db", 
            "weights_nolnc/mashr_Adipose_Subcutaneous_nolnc_harmonized.db")

outname <- "example_multigroup_preharm"

ncore <- 6

# impute gene z-scores for both sets of prediction weights by chromosome
for (i in 1:22){
  if (!file.exists(paste0(outputdir, outname, "_chr", i, ".expr.gz"))){
    res <- impute_expr_z(z_snp = z_snp,
                         weight = weight,
                         ld_R_dir = ld_R_dir,
                         outputdir = outputdir,
                         outname = outname,
                         harmonize_z = F,
                         harmonize_wgt = F,
                         ncore=ncore, 
                         chrom=i)
  }
}

# combine the imputed gene z-scores
ld_exprfs <- paste0(outputdir, outname, "_chr", 1:22, ".expr.gz")

z_gene <- list()

for (i in 1:22){
  load(paste0(outputdir, outname, "_chr", i, ".exprqc.Rd"))
  z_gene[[i]] <- z_gene_chr
}

z_gene <- do.call(rbind, z_gene)
rownames(z_gene) <- NULL

rm(qclist, wgtlist, z_gene_chr)
```

_The output of these commands is identical to harmonizing within the `impute_expr_z` function, although the genes are now named after the "_harmonized" `.db` files. _

_* In this version of cTWAS, we've included two options to parallelize and divide up the imputation. First, we've added the option `ncore` to specify the number of cores to use during imputation. Second, we've added the option to impute over a subset of chromosomes, allowing the imputation to be divided into multiple jobs._

_* We've also added an option to take no additional action beyond simple harmonization with strand ambiguous weights. We replaced the option `recover_strand_ambig_wgt = TRUE/FALSE` from the `main` branch with the option `strand_ambig_action_wgt = c("drop", "none", "recover")`. The `"drop"` option is equivalent to `FALSE` from the `main` branch, and `"recover"` is equivalent to `TRUE`. The new `"none"` option treats strand ambiguous weights as unambiguous; it does the initial simple harmonization (flipping based on allele matching) but then doesn't do anything else to the ambiguous weights. The default behavior has changed from `recover_strand_ambig_wgt = TRUE` in the `main` branch to `recover_strand_ambig_wgt = "drop"` in order to be consistent with default of `strand_ambig_action_z`. Code using `cTWAS` from the `main` branch or previous versions of the `multigroup` branch (`0.1.39` or earlier) needs to be updated to reflect this change._

<span style="color: red;">NOTE: The parallelized version of this function has some memory issues when `strand_ambig_action_wgt = "recover"` and multiple cores are used. I think that this needs to be fixed by dividing up the covariances provided by PredictDB into chunks, storing them, and then loading specific groups by core. Currently, all the covariances are made available to every core. For analyses with many sets of weights, it may not be possible to recover strand ambiguous weights and also use multiple cores until this memory issue is corrected. </span>


## Running cTWAS fine-mapping with fixed parameters at a single locus

After imputing gene z-scores, we are ready to run the cTWAS analysis. The full analysis involves first estimating parameters from the data, and then fine-mapping the genes and variants using these estimated parameters. This can be computationally intensive, so for this example, we will only run the fine-mapping step at an example locus, using the parameters we estimated in the paper.

```{r}
# load imputed gene z-scores, the harmonized GWAS z-scores
load(paste0(outputdir, "/", outname, "_z_gene.Rd"))
load(paste0(outputdir, "/", outname, "_z_snp.Rd"))
```

Let's run the cTWAS fine-mapping step at the HPR locus using the estimated parameters:

```{r ctwas_rss_finemapping, eval=FALSE}
# the estimated prior inclusion probabilities for genes and variants from the paper
group_prior <- c(0.0107220302, 0.0001715896)

# the estimated effect sizes for genes and variants from the paper
group_prior_var <- c(41.327666, 9.977841)

# run ctwas_rss
ctwas_rss(z_gene = z_gene_subset,
          z_snp = z_snp_subset,
          ld_exprvarfs = ld_exprvarfs,
          ld_R_dir = ld_R_dir,
          ld_regions_custom = regions_file,
          outputdir = outputdir,
          outname = outname,
          estimate_group_prior = F,
          estimate_group_prior_var = F,
          group_prior = group_prior,
          group_prior_var = group_prior_var)
```

## Running cTWAS genome-wide with multiple weights

<span style="color: red;">TODO: This section needs to be updated. </span>

### Estimating parameters 

In the `multigroup` branch, we've included an option (`fine_map=F`) to run only the parameter estimation step in `ctwas_rss`. This makes it easier to divide larger analyses into shorter individual jobs.

To specify that our gene z-scores come from multiple groups, we simply add a `type` column specifying the group name for each gene. We use the following code to extract the tissue label from the concatenated gene names. Note that this code parses the specific prediction model names in our analysis and will need to be adjusted when using other data. For example, this code would give the same group name ("Adipose") to both "Adipose_Subcutaneous" and "Adipose_Visceral_Omentum" if using those tissues.

```{r}
# set the type for each gene (i.e. tissue)
z_gene$type <- sapply(z_gene$id, function(x){unlist(strsplit(unlist(strsplit(x, "[|]"))[2],"_"))[2]})

head(z_gene)
```

In addition to the options we specified in the `main` branch cTWAS tutorial, we've added an option (`ncore_LDR`) to parallelize the creation of the SNP-by-gene and gene-by-gene correlation matrices: 
```{r}
# options used in main branch tutorial
thin <- 0.1
max_snp_region <- 20000
ncore <- 6

# additional options for the multigroup branch
fine_map <- F
ncore_LDR <- 6
```

In the `multigroup` branch, there are several options for how to handle the effect size prior. By default, each group has its own independent effect size parameter (`group_prior_var_stucture = "shared"`). This allows for group-specific priors but may also be too flexible if these parameters are not well informed. In this example, we specify that the non-SNP groups should share a single effect size parameter (`group_prior_var_structure = "shared"`). There is also the option to have the non-SNP groups share an effect size with the variants as well (`group_prior_var_structure = "shared+snps"`). Finally, there is an option to place an inverse-Gamma prior on independent variances for each group (`group_prior_var_structure = "inv_gamma"`); the prior parameters are controlled using the `inv_gamma_shape` and `inv_gamma_rate` options.

```{r}
# prior variance structure
group_prior_var_structure <- "shared"
```

We are now ready to run the parameter estimation step using cTWAS. As specified, this step took approximately 9 hours, using 6 cores. 

```{r}

if (file.exists(paste0(outputdir, outname, ".s2.susieIrssres.Rd"))){
  load(paste0(outputdir, outname, ".s2.susieIrssres.Rd"))
  
  group_prior <- group_prior_rec[,ncol(group_prior_rec)]
  group_prior["SNP"] <- group_prior["SNP"]*thin #adjust for thin argument
  
  group_prior_var <- group_prior_var_rec[,ncol(group_prior_var_rec)]
  
  rm(group_prior_rec, group_prior_var_rec)
} else {
  parameters <- ctwas_rss(z_gene = z_gene, 
                          z_snp = z_snp, 
                          ld_exprfs = ld_exprfs, 
                          ld_R_dir = ld_R_dir, 
                          ld_regions = "EUR",
                          ld_regions_version = "b38",
                          outputdir = outputdir, 
                          outname = outname,
                          thin = thin,
                          max_snp_region = max_snp_region,
                          ncore = ncore,
                          ncore_LDR = ncore_LDR,
                          group_prior_var_structure = group_prior_var_structure,
                          fine_map = fine_map)
  
  group_prior <- parameters$group_prior
  group_prior_var <- parameters$group_prior_var
}

group_prior
group_prior_var

```

Both the `group_prior` and `group_prior_var` objects are named vectors containing the parameter estimates. In the `main` branch, these objects were not named. Note that the effect size estimates for Liver and Adipose are identical because we specified that they would share a single parameter.

<span style="color: red;">NOTE: This parameter-estimation-only step still computes the SNP-by-gene and gene-by-gene matrices even though it doesn't need to. Of the 9 hours that this ran, approximately 1.5 hours were spent computing these matrices (and indexing genes/variants to regions, not sure what proportion of time is just building the matrices). These matrices are computed again during the fine-mapping-only step although they could be recycled. They are only computed once when running the combined parameter estimation and fine-mapping. The simplest option to avoid this computation would be to set the SNP-by-gene matrices to contain all zeros and the gene-by-gene matrices to be identity matrices when `fine_map=F`. This option that would need to be passed to the `index_regions` function, which computes the LDR matrices. This would avoid some computation (not sure exactly how much) but the downside is that this would still save a lot of (effectively empty) files in the LDR folder, so it isn't the cleanest fix. </span>

In this example, regions are merged (`merge=T`) and analyzed jointly when a gene spans a region boundary, which is the default behavior. However, if many prediction models are specified, this could lead to excessive region merging, even if prediction models are sparse. If more than a handful of regions are merged, there many be computational issues in subsequent steps. In my experience running this analysis using prediction models from all 49 GTEx tissues, region merging was not tractable. Turning region merging off (`merge=F`) discards all genes that span region boundaries. This will resolve computational issues around excessive region merging but will also prevent the analysis of boundary-spanning genes. For larger analyses, turning off region merging will likely be necessary. I think that this issue is currently the biggest limitation to using the `multigroup` branch.

### Assessing parameter estimates

We provide code to assess the convergence of the estimated parameters and to compute the proportion of variance explained (PVE) by variants and genes. Note that this function has been modified from the `main` branch in order to accommodate multiple groups and the named objects returned by the `multigroup` branch.

```{r, eval=FALSE}
ctwas_parameters <- ctwas_summarize_parameters(outputdir = outputdir, 
                                               outname = outname, 
                                               gwas_n = gwas_n, 
                                               thin = thin)

#estimated prior inclusion probability
ctwas_parameters$group_prior

#estimated prior effect size
ctwas_parameters$group_prior_var

#estimated enrichment of genes over variants
ctwas_parameters$enrichment

#PVE explained by genes and variants
ctwas_parameters$group_pve

#total heritability (sum of PVE)
ctwas_parameters$total_pve

#attributable heritability
ctwas_parameters$attributable_pve

#plot convergence
ctwas_parameters$convergence_plot
```

### Fine-mapping

We now perform the fine-mapping step with the parameters that we estimated in the previous step. Note that the options used in the fine-mapping step should be the same as in parameter estimation step (e.g. if setting `merge=F`, make sure to specify it in both functions). The `group_prior_var_strucutre` option is only necessary during parameter estimation.

As specified, this step took approximately 3.5 hours, using 6 cores. 

```{r, eval=FALSE}
ctwas_rss(z_gene = z_gene, 
          z_snp = z_snp, 
          ld_exprfs = ld_exprfs, 
          ld_R_dir = ld_R_dir, 
          ld_regions = "EUR",
          ld_regions_version = "b38",
          outputdir = outputdir, 
          outname = outname,
          thin = thin,
          max_snp_region = max_snp_region,
          ncore = ncore,
          ncore_LDR = ncore_LDR,
          group_prior = group_prior, 
          group_prior_var = group_prior_var, 
          estimate_group_prior = F, 
          estimate_group_prior_var = F)

```

<span style="color: red;">NOTE: If `thin` is specified, then for regions with a gene having PIP greater than `rerun_gene_PIP`, cTWAS makes a final pass, analyzing these regions using the full set of variants. However, this behavior may not be appropriate for the multigroup version. In the context of prediction models with multiple tissues, cTWAS will only be re-run if a single gene/tissue pair is over the threshold. If prediction models across tissues are correlated, there could be a high probability of a gene effect in a region, but with high uncertainty on which tissue, and thus a relatively low PIP on any particular gene/tissue pair. cTWAS would not be re-run in this case, and this region would only contain results using thinned variants. </span>

### Viewing the results

As before, we will add the gene names to the results (the PredictDB weights use Ensembl IDs as the primary identifier), as well as the z-scores for each SNP and gene. We then show all genes with PIP greater than 0.8, which is the threshold we used in the paper.

```{r, eval=FALSE}

#load cTWAS results
ctwas_res <- read.table(paste0(outputdir, outname, ".susieIrss.txt"), header=T)

#load information for all genes
gene_info <- data.frame(gene=as.character(), genename=as.character(), gene_type=as.character(), weight=as.character())

for (i in 1:length(weight)){
  sqlite <- RSQLite::dbDriver("SQLite")
  db = RSQLite::dbConnect(sqlite, weight[i])
  query <- function(...) RSQLite::dbGetQuery(db, ...)
  gene_info_current <- query("select gene, genename, gene_type from extra")
  RSQLite::dbDisconnect(db)

  gene_info_current$weight <- weight[i]
  
  gene_info <- rbind(gene_info, gene_info_current)
}

gene_info$weight <- sapply(gene_info$weight, function(x){rev(unlist(strsplit(tools::file_path_sans_ext(x), "/")))[1]})
gene_info$id <- paste(gene_info$gene, gene_info$weight, sep="|")

#add gene names to cTWAS results
ctwas_res$genename[ctwas_res$type!="SNP"] <- gene_info$genename[match(ctwas_res$id[ctwas_res$type!="SNP"], gene_info$id)]

rm(gene_info)

#add z-scores to cTWAS results
ctwas_res$z[ctwas_res$type=="SNP"] <- z_snp$z[match(ctwas_res$id[ctwas_res$type=="SNP"], z_snp$id)]
ctwas_res$z[ctwas_res$type!="SNP"] <- z_gene$z[match(ctwas_res$id[ctwas_res$type!="SNP"], z_gene$id)]

#display the genes with PIP > 0.8
ctwas_res <- ctwas_res[order(-ctwas_res$susie_pip),]
ctwas_res[ctwas_res$type!="SNP" & ctwas_res$susie_pip > 0.8,]

```

In the context of genes in multiple tissues, it is also useful to evaluate the PIP for each gene combined over tissues:

```{r, eval=FALSE}

# aggregate by gene name
df_gene <- aggregate(ctwas_res$susie_pip[ctwas_res$type!="SNP"], by=list(ctwas_res$genename[ctwas_res$type!="SNP"]), FUN=sum)
colnames(df_gene) <- c("genename", "combined_pip")

# drop duplicated gene names
df_gene <- df_gene[!(df_gene$genename %in% names(which(table(ctwas_res$genename)>length(weight)))),]

# collect tissue-level results
all_tissue_names <- unique(ctwas_res$type[ctwas_res$type!="SNP"])

df_gene_pips <- matrix(NA, nrow=nrow(df_gene), ncol=length(all_tissue_names))
colnames(df_gene_pips) <- all_tissue_names

ctwas_gene_res <- ctwas_res[ctwas_res$type!="SNP",]

for (i in 1:nrow(df_gene)){
  gene <- df_gene$genename[i]
  ctwas_gene_res_subset <- ctwas_gene_res[which(ctwas_gene_res$genename==gene),]
  df_gene_pips[i,ctwas_gene_res_subset$type] <- ctwas_gene_res_subset$susie_pip
}

df_gene <- cbind(df_gene, df_gene_pips)

rm(df_gene_pips, ctwas_gene_res, ctwas_gene_res_subset)

#sort by combined PIP
df_gene <- df_gene[order(-df_gene$combined_pip),]
df_gene <- df_gene[,apply(df_gene, 2, function(x){!all(is.na(x))})] #drop genes that weren't imputed in any tissue

#genes with PIP>0.8 or 20 highest PIPs
head(df_gene, max(sum(df_gene$combined_pip>0.8), 20))

```

<span style="color: red;">NOTE: To visualize individual loci, the `ctwas_locus_plot` function will need to be updated to accommodate multiple groups. </span>

